/**
 * @author Erwin Yukselgil
 * Created on 06.04.2005
 * Version 1.0
 * 
 * This class is there to provide rules for message interaction of two state machines.
 * bothHaveNoTrigger(), oneHasTRigger() and bothHaveTrigger() are the three main constellations for two state machines  
 * each produces rules, which are implemented as procedure calls for better reading. 
 * Several rules can be produced more than once, therefore all rules are saved in a HashMap, with the name as key and thus exists only once
 *  
 */


package tum.umlsec.viki.tools.uml2tptp.statechartreader;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Vector;

class InputOutputRules {
    
    private HashMap rules = new HashMap();
    private String aRule = new String();
    
    /**
     * when instantiating this class all needed rules are generated by calling
     * the three main methods
     */
    InputOutputRules(){
        bothHaveNoTrigger();
        oneHasTrigger();
        bothHaveTrigger();
        oneHasEnded();
    }
    
    /**
     * this method is called by Statechartreader to get rules concerning the in- and output
     * @return Vector containing rules as String
     */
    Vector returnRules(){
        Vector _result = new Vector();
        Iterator rulesIterator;
        
        rulesIterator = rules.keySet().iterator();
        
        while(rulesIterator.hasNext()){
            _result.addElement((String) rules.get(rulesIterator.next()));    
        }       
        
        return _result;    
    }
    
    
    /**
     * writes all necessary rules to HashMap rule to cover this constellation
     */
    private void bothHaveNoTrigger(){
        
        aRule = "input_formula(bothHaveNoTriggerRule,axiom, " +
        		"(![S1,S2,N] : ((hasNoTrigger(S1,N) & hasNoTrigger(S2,N) & (S1 != S2))" +
        		" => (checkIncoming(S1,N) & checkIncoming(S2,N))))).";
	    rules.put("bothHaveNoTriggerRule",aRule);
	    
	    //first state machine
	    checkIncoming();
			//hasIncoming OR hasNoIncoming
	    	hasIncoming();
	        	refreshOtherPointers();
	        	refreshOtherQueueSizesAndAllQueueElements();
		    
		    hasNoIncoming();
	        	refreshAllPointers();
	        	refreshAllQueueSizesAndAllQueueElements();

		//AND second state machine
		checkIncoming();
			//hasIncoming OR hasNoIncoming
		    hasIncoming();
	        	refreshOtherPointers();
	        	refreshOtherQueueSizesAndAllQueueElements();
		    
		    hasNoIncoming();
	        	refreshAllPointers();
	        	refreshAllQueueSizesAndAllQueueElements();
    }
    
    
    private void checkIncoming(){

        aRule = "input_formula(checkIncoming1Rule,axiom, " +
    			"(![S1,S2,N] : ((checkIncoming(S1,N) & hasEffectToSend(S2,N) & (S1 != S2))" +
    			" => (hasIncoming(S1,N))))).";
        rules.put("checkIncoming1",aRule);

        aRule = "input_formula(checkIncoming2Rule,axiom, " +
    			"(![S1,S2,N] : ((checkIncoming(S1,N) & hasNoEffectToSend(S2,N) & (S1 != S2))" +
    			" => (hasNoIncoming(S1,N))))).";
        rules.put("checkIncoming2",aRule);    
    }

    
    private void hasIncoming(){
        
	    aRule = "input_formula(hasIncomingRule,axiom, " +
				"(![S1,S2,MsgID,N,QueueSizeAt,QueuePointerAt]: ((hasIncoming(S1,succ(N)) & effect(S2,S1,MsgID,succ(N)) & queueSize(S1,MsgID,N,QueueSizeAt) & queuePointer(S1,MsgID,N,QueuePointerAt) & (S1 != S2))" +
				" => (queueSize(S1,MsgID,succ(N),succ(QueueSizeAt)) & queuePointer(S1,MsgID,succ(N),QueuePointerAt) & ~queuePointer(S1,MsgID,succ(N),succ(QueueSizeAt)) & refreshOtherPointers(S1,MsgID,succ(N)) & refreshOtherQueueSizesAndAllQueueElements(S1,MsgID,succ(N)))))).";
	    rules.put("hasIncoming",aRule);	    
    }

    
    private void hasNoIncoming(){
	    
        aRule = "input_formula(hasNoIncomingRule,axiom, " +
        		"(![S,N]: ((hasNoIncoming(S,N))" +
				" => (refreshAllPointers(S,N) & refreshAllQueueSizesAndAllQueueElements(S,N))))).";
        rules.put("hasNoIncoming",aRule);	
    }

    
    private void refreshAllPointers(){
	    
		aRule = "input_formula(refreshAllPointersRule,axiom, " +
				"(![S,MsgID,N,QueuePointerAt] : ((refreshAllPointers(S,succ(N)) & queuePointer(S,MsgID,N,QueuePointerAt))" +
				" => (queuePointer(S,MsgID,succ(N),QueuePointerAt))))).";
		rules.put("refreshAllPointers",aRule);
    }
	
    
    private void refreshAllQueueSizesAndAllQueueElements(){
	
		aRule = "input_formula(refreshAllQueueSizesAndAllQueueElementsRule,axiom, " +
				"(![S,MsgID,N,QueuePointerAt,QueueSizeAt] : ((refreshAllQueueSizesAndAllQueueElements(S,succ(N)) & queuePointer(S,MsgID,succ(N),QueuePointerAt) & queueSize(S,MsgID,N,QueueSizeAt))" +
				" => (queueSize(S,MsgID,succ(N),QueueSizeAt) & refreshQueueElements(S,MsgID,succ(N),QueuePointerAt))))).";
		rules.put("refreshAllQueueSizesAndAllQueueElements",aRule);
    }
    
    
    private void refreshOtherPointers(){
	    
		aRule = "input_formula(refreshOtherPointersRule,axiom, " +
				"(![S1,MsgID1,MsgID2,N,QueuePointerAt] : ((refreshOtherPointers(S1,MsgID1,succ(N)) & queuePointer(S1,MsgID2,N,QueuePointerAt) & (MsgID1 != MsgID2))" +
				" => (queuePointer(S1,MsgID2,succ(N),QueuePointerAt))))).";
		rules.put("refreshOtherPointers",aRule);        
    }
    
    
    private void refreshOtherQueueSizesAndAllQueueElements(){
	    
		aRule = "input_formula(refreshOtherQueueSizesAndAllQueueElementsRule,axiom, " +
				"(![S1,MsgID1,N,QueuePointerAt] : ((refreshOtherQueueSizesAndAllQueueElements(S1,MsgID1,N) & queuePointer(S1,MsgID1,N,QueuePointerAt))" +
				" => (refreshOtherQueueSizes(S1,MsgID1,N) & refreshQueueElements(S1,MsgID1,N,QueuePointerAt) & refreshOtherQueueElements(S1,MsgID1,N))))).";
		rules.put("refreshOtherQueueSizesAndAllQueueElements",aRule);

		aRule = "input_formula(refreshOtherQueueSizesRule,axiom, " +
				"(![S1,MsgID1,MsgID2,N,QueueSizeAt] : ((refreshOtherQueueSizes(S1,MsgID1,succ(N)) & queueSize(S1,MsgID2,N,QueueSizeAt) & (MsgID1 != MsgID2))" +
				" => (queueSize(S1,MsgID2,succ(N),QueueSizeAt))))).";
		rules.put("refreshOtherQueueSizes",aRule);

		aRule = "input_formula(refreshOtherQueueElementsRule,axiom, " +
				"(![S1,MsgID1,MsgID2,N,QueuePointerAt] : ((refreshOtherQueueElements(S1,MsgID1,succ(N)) & queuePointer(S1,MsgID2,succ(N),QueuePointerAt) & (MsgID1 != MsgID2))" +
				" => (refreshQueueElements(S1,MsgID2,succ(N),QueuePointerAt))))).";
		rules.put("refreshOtherQueueElements",aRule);
		
		aRule = "input_formula(refreshQueueElementsRule,axiom, " +
				"(![S1,MsgID1,N,QueuePointerAt] : ((refreshQueueElements(S1,MsgID1,succ(N),QueuePointerAt) & ~queuePointer(S1,MsgID1,N,succ(QueuePointerAt)))" +
				" => (refreshQueueElements(S1,MsgID1,succ(N),succ(QueuePointerAt)) & ~queuePointer(S1,MsgID1,succ(N),succ(QueuePointerAt)))))).";
		rules.put("refreshQueueElements",aRule);
    }
    
    
    /**
     * writes all necessary rules to HashMap rule to cover this constellation
     */
    private void oneHasTrigger(){

        aRule = "input_formula(oneHasTriggerRule,axiom, " +
        		"(![S1,S2,MsgID,N] : ((hasTrigger(S1,MsgID,N) & hasNoTrigger(S2,N) & (S1 != S2))" +
        		" => (checkQueue(S1,MsgID,N) & waiting(S2,N))))).";
		rules.put("oneHasTrigger",aRule);

		//first state machine
		checkQueue();
		
			//queueHasElement OR queueHasNoElement
			queueHasElement();
			//*
				refreshOtherPointers();
				checkIncomingWithUpdatedPointers();
				//hasIncomingWithUpdatedPointers OR hasNoIncomingWithUpdatedPointers
					hasIncomingWithUpdatedPointers();
						refreshOtherQueueSizesAndAllQueueElements();
					
					hasNoIncomingWithUpdatedPointers();
						refreshAllQueueSizesAndAllQueueElements();
						
		    queueHasNoElement();
			    checkForMatch();
			    	//matchFound OR noMatchFound
			    	matchFound();
			    	//*
				    	refreshOtherPointers();
						refreshAllQueueSizesAndAllQueueElements();
								
			    	noMatchFound();
			    	//**
			    		checkIncoming();
			    			//hasIncoming OR hasNoIncoming
					    	hasIncoming();
					        	refreshOtherPointers();
					        	refreshOtherQueueSizesAndAllQueueElements();
						    
						    hasNoIncoming();
					        	refreshAllPointers();
					        	refreshAllQueueSizesAndAllQueueElements();
					        	
		//second state machine
        //* first rule of
		stopWaiting();
        //** second rule of
		stopWaiting();
    }
    

    private void checkQueue(){

        aRule = "input_formula(checkQueue1Rule,axiom, " +
				"(![S,MsgID,N,QueuePointerAt] : ((checkQueue(S,MsgID,succ(N)) & queuePointer(S,MsgID,N,QueuePointerAt) & ~queuePointer(S,MsgID,N,succ(QueuePointerAt)))" +
				" => queueHasElement(S,MsgID,succ(N))))).";
		rules.put("checkQueue1",aRule);
		
		aRule = "input_formula(checkQueue2Rule,axiom, " +
				"(![S,MsgID,N,QueueSizeAt] : ((checkQueue(S,MsgID,succ(N)) & queuePointer(S,MsgID,N,QueueSizeAt) & queueSize(S,MsgID,N,QueueSizeAt))" +
				" => (queueHasNoElement(S,MsgID,succ(N)))))).";
		rules.put("checkQueue2",aRule);
    }
   
    
    private void queueHasElement(){

		aRule = "input_formula(queueHasElementRule,axiom, " +
				"(![S1,MsgID1,N,QueuePointerAt] : ((queueHasElement(S1,MsgID1,succ(N)) & queuePointer(S1,MsgID1,N,QueuePointerAt))" +
				" => (trigger(S1,MsgID1,succ(N)) & queuePointer(S1,MsgID1,succ(N),succ(QueuePointerAt)) & refreshOtherPointers(S1,MsgID1,succ(N)) & checkIncomingWithUpdatedPointers(S1,succ(N)))))).";
		rules.put("queueHasElement",aRule);	
	}    
    
    
    private void queueHasNoElement(){

		aRule = "input_formula(queueHasNoElementRule,axiom, " +
				"(![S1,MsgID1,N] : ((queueHasNoElement(S1,MsgID1,N))" +
				" => (checkForMatch(S1,MsgID1,N))))).";
		rules.put("queueHasNoElement",aRule);	
	}

    
    private void checkForMatch(){

        aRule = "input_formula(checkForMatch1Rule,axiom, " +
				"(![S1,S2,MsgID1,MsgID2,N] : ((checkForMatch(S1,MsgID1,N) & effect(S2,S1,MsgID2,N) & (S1 != S2) & ~(MsgID1 != MsgID2))" +
				" => (matchFound(S1,MsgID1,N))))).";
        rules.put("checkForMatch1",aRule);

        aRule = "input_formula(checkForMatch2Rule,axiom, " +
        		"(![S1,S2,MsgID1,MsgID2,N] : ((checkForMatch(S1,MsgID1,N) & ((effect(S2,S1,MsgID2,N) & (MsgID1 != MsgID2)) | hasNoEffectToSend(S2,N)) & (S1 != S2))" +
        		" => (noMatchFound(S1,MsgID1,N))))).";
        rules.put("checkForMatch2",aRule);
    }
    
    
    private void matchFound(){

        aRule = "input_formula(incomingMatchesTriggerRule,axiom, " +
				"(![S1,S2,MsgID1,MsgID2,N,QueueSizeAt1] : ((matchFound(S1,MsgID1,succ(N)) & effect(S2,S1,MsgID2,succ(N)) & queuePointer(S1,MsgID1,N,QueueSizeAt1) & (S1 != S2) & ~(MsgID1 != MsgID2))" +
				" => (trigger(S1,MsgID1,succ(N)) & queueSize(S1,MsgID1,succ(N),succ(QueueSizeAt1)) & queuePointer(S1,MsgID1,succ(N),succ(QueueSizeAt1)) & refreshOtherPointers(S1,MsgID1,succ(N)) & refreshOtherQueueSizesAndAllQueueElements(S1,MsgID1,succ(N)))))).";
        rules.put("incomingMatchesTrigger",aRule);
    }
    
    
    private void noMatchFound(){

		aRule = "input_formula(incomingMatchesNotTriggerRule,axiom, " +
				"(![S1,MsgID1,N] : ((noMatchFound(S1,MsgID1,N))" +
				" => (~trigger(S1,MsgID1,N) & checkIncoming(S1,N))))).";
		rules.put("incomingMatchesNotTrigger",aRule);        
    }
    
    
    private void checkIncomingWithUpdatedPointers(){

        aRule = "input_formula(checkIncomingWithUpdatedPointers1Rule,axiom, " +
    			"(![S1,S2,N] : ((checkIncomingWithUpdatedPointers(S1,N) & hasEffectToSend(S2,N) & (S1 != S2))" +
    			" => (hasIncomingWithUpdatedPointers(S1,N))))).";
        rules.put("checkIncomingWithUpdatedPointers1",aRule);

        aRule = "input_formula(checkIncomingWithUpdatedPointers2Rule,axiom, " +
    			"(![S1,S2,F,N] : ((checkIncomingWithUpdatedPointers(S1,N) & (hasNoEffectToSend(S2,N) | final(S2,F,N)) & (S1 != S2))" +
    			" => (hasNoIncomingWithUpdatedPointers(S1,N))))).";
        rules.put("checkIncomingWithUpdatedPointers2",aRule);    
    }

    
    private void hasIncomingWithUpdatedPointers(){
        
	    aRule = "input_formula(hasIncomingWithUpdatedPointersRule,axiom, " +
				"(![S1,S2,MsgID,N,QueueSizeAt,QueuePointerAt]: ((hasIncomingWithUpdatedPointers(S1,succ(N)) & effect(S2,S1,MsgID,succ(N)) & queueSize(S1,MsgID,N,QueueSizeAt) & (S1 != S2))" +
				" => (queueSize(S1,MsgID,succ(N),succ(QueueSizeAt)) & ~queuePointer(S1,MsgID,succ(N),succ(QueueSizeAt)) & refreshOtherQueueSizesAndAllQueueElements(S1,MsgID,succ(N)))))).";
	    rules.put("hasIncomingWithUpdatedPointers",aRule);	    
    }
    
    
    private void hasNoIncomingWithUpdatedPointers(){
	    
        aRule = "input_formula(hasNoIncomingWithUpdatedPointersRule,axiom, " +
        		"(![S,MsgID,N]: ((hasNoIncomingWithUpdatedPointers(S,N))" +
				" => (refreshAllQueueSizesAndAllQueueElements(S,N))))).";
        rules.put("hasNoIncomingWithUpdatedPointers",aRule);	
    } 
    
    
    private void stopWaiting(){

        aRule = "input_formula(stopWaitingRule1,axiom, " +
        		"(![S1,S2,MsgID,N]: ((waiting(S1,N) & trigger(S2,MsgID,N) & (S1 != S2))" +
				" => (checkIncoming(S1,N))))).";
        rules.put("stopWaiting1",aRule);

        aRule = "input_formula(stopWaitingRule2,axiom, " +
        		"(![S1,S2,MsgID,N]: ((waiting(S1,N) & ~trigger(S2,MsgID,N) & (S1 != S2))" +
				" => (hasNoIncoming(S1,N))))).";
        rules.put("stopWaiting1",aRule);
    }
    
    
    /**
     * writes all necessary rules to HashMap rule to cover this constellation
     */
    private void bothHaveTrigger(){

		aRule = "input_formula(bothHaveTriggerRule,axiom, " +
				"(![S1,S2,MsgID1,MsgID2,N] : ((hasTrigger(S1,MsgID1,N) & hasTrigger(S2,MsgID2,N) & (S1 != S2))" +
				" => (checkBothQueues(S1,S2,MsgID1,MsgID2,N))))).";
		rules.put("bothHaveTrigger",aRule);
		
		checkBothQueues();
			//bothHaveElements
			//first AND second state machine
			queueHasElement();
			//*
				refreshOtherPointers();
				checkIncomingWithUpdatedPointers();
				//hasIncomingWithUpdatedPointers OR hasNoIncomingWithUpdatedPointers
					hasIncomingWithUpdatedPointers();
						refreshOtherQueueSizesAndAllQueueElements();
					
					hasNoIncomingWithUpdatedPointers();
						refreshAllQueueSizesAndAllQueueElements();
			
			//oneHasElement
			//first state machine
			//second state machine is blocked
			queueHasElement();
			//*
				refreshOtherPointers();
				checkIncomingWithUpdatedPointers();
				//hasIncomingWithUpdatedPointers OR hasNoIncomingWithUpdatedPointers
					hasIncomingWithUpdatedPointers();
						refreshOtherQueueSizesAndAllQueueElements();
					
					hasNoIncomingWithUpdatedPointers();
						refreshAllQueueSizesAndAllQueueElements();
			
			
			//* for second state machine how the case may be, first rule or second rule applies
			checkBlock();
				//checkForMatch OR else
				checkForMatch();
					//matchFound OR noMatchFound
			    	matchFound();
			    	//*
				    	refreshOtherPointers();
						refreshAllQueueSizesAndAllQueueElements();
								
			    	noMatchFound();
			    	//**
			    		checkIncoming();
			    			//hasIncoming OR hasNoIncoming
					    	hasIncoming();
					        	refreshOtherPointers();
					        	refreshOtherQueueSizesAndAllQueueElements();
						    
						    hasNoIncoming();
					        	refreshAllPointers();
					        	refreshAllQueueSizesAndAllQueueElements();
					        	
		       refreshAllPointers();
		       refreshAllQueueSizesAndAllQueueElements();		
	}
    
    
    private void checkBothQueues(){

        aRule = "input_formula(checkBothQueues1Rule,axiom, " +
				"(![S1,S2,MsgID1,MsgID2,N,QueuePointerAt1,QueuePointerAt2] : ((checkBothQueues(S1,S2,MsgID1,MsgID2,succ(N)) & queuePointer(S1,MsgID1,N,QueuePointerAt1) & ~queuePointer(S1,MsgID1,N,succ(QueuePointerAt1)) & queuePointer(S2,MsgID2,N,QueuePointerAt2) & ~queuePointer(S2,MsgID2,N,succ(QueuePointerAt2)) & (S1 != S2))" +
				" => (queueHasElement(S1,MsgID1,succ(N)) & queueHasElement(S2,MsgID2,succ(N)))))).";
        rules.put("checkBothQueues1",aRule);

        aRule = "input_formula(checkBothQueues2Rule,axiom, " +
				"(![S1,S2,MsgID1,MsgID2,N,QueuePointerAt1,QueueSizeAt2] : ((checkBothQueues(S1,S2,MsgID1,MsgID2,succ(N)) & queuePointer(S1,MsgID1,N,QueuePointerAt1) & ~queuePointer(S1,MsgID1,N,succ(QueuePointerAt1)) & queueSize(S2,MsgID2,N,QueueSizeAt2) & queuePointer(S2,MsgID2,N,QueueSizeAt2) & (S1 != S2))" +
				" => (queueHasElement(S1,MsgID1,succ(N)) & blocked(S2,MsgID2,succ(N)))))).";
        rules.put("checkBothQueues2",aRule);
        
        aRule = "input_formula(checkBothQueues3Rule,axiom, " +
				"(![S1,S2,MsgID1,MsgID2,N,QueueSizeAt1,QueuePointerAt2] : ((checkBothQueues(S1,S2,MsgID1,MsgID2,succ(N)) & queueSize(S1,MsgID1,N,QueueSizeAt1) & queuePointer(S1,MsgID1,N,queueSizeAt1) & queueSize(S2,MsgID2,N,queueSizeAt2) & queuePointer(S2,MsgID2,N,queueSizeAt2) & (S1 != S2))" +
				" => (deadlock(S1,S2,succ(N)))))).";
        rules.put("checkBothQueues3",aRule);
    }

    
    private void checkBlock(){
        
        aRule = "input_formula(checkBlock1Rule,axiom, " +
				"(![S1,S2,MsgID1,MsgID2,N] : ((blocked(S1,MsgID1,N) & trigger(S2,MsgID2,N) & (S1 != S2))" +
				" => (checkForMatch(S1,MsgID1,succ(N)))))).";
        rules.put("checkBlock1",aRule);

        aRule = "input_formula(checkBlock2Rule,axiom, " +
				"(![S1,S2,MsgID1,MsgID2,N] : ((blocked(S1,MsgID1,N) & ~trigger(S2,MsgID2,N) & (S1 != S2))" +
				" => (~trigger(S1,MsgID1,succ(N)) & refreshAllPointers(S1,N) & refreshAllQueueSizesAndAllQueueElements(S1,N))))).";
        rules.put("checkBlock2",aRule);        
    }
    
    
    /**
     * writes all necessary rules to HashMap rule to cover this constellation
     */
    private void oneHasEnded(){

		aRule = "input_formula(oneHasEndedRule,axiom, " +
				"(![S1,S2,MsgID1,F,N] : ((hasTrigger(S1,MsgID1,N) & final(S2,F,N) & (S1 != S2))" +
				" => (checkQueue(S1,MsgID1,N) & endOf(S2,N))))).";
		rules.put("oneHasEnded",aRule);
		
		//first state machine only
		checkQueue();
			//queueHasElement OR queueHasNoElement
			queueHasElement();
				refreshOtherPointers();
				checkIncomingWithUpdatedPointers();
					hasNoIncomingWithUpdatedPointers();
						refreshAllQueueSizesAndAllQueueElements();
			
			queueHasNoElement();
				deadlock2();
	}
    
    
    private void deadlock2(){

		aRule = "input_formula(deadlock2Rule,axiom, " +
				"(![S1,S2,MsgID1,N] : ((queueHasNoElement(S1,MsgID1,N) & endOf(S2,N) & (S1 != S2))" +
				" => (deadlock(S1,S2,N))))).";
		rules.put("deadlock2",aRule);        
    }
}
